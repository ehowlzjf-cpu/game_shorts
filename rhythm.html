<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Drop</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 360px;
            height: 640px;
            overflow: hidden;
            background: #000;
        }
        canvas { display: block; }
        #start-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #start-text {
            font-family: 'Helvetica Neue', sans-serif;
            font-size: 24px;
            font-weight: 200;
            color: #fff;
            letter-spacing: 8px;
            animation: fade 2s ease-in-out infinite;
        }
        @keyframes fade {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        #phase {
            position: absolute;
            top: 20px; left: 20px;
            font-family: 'Helvetica Neue', sans-serif;
            font-size: 12px;
            font-weight: 300;
            color: rgba(255,255,255,0.4);
            letter-spacing: 3px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="canvas"></canvas>
        <div id="phase">PHASE 1</div>
        <div id="start-screen">
            <div id="start-text">TAP</div>
        </div>
    </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const W = 360, H = 640;
canvas.width = W;
canvas.height = H;

let audioCtx = null;
let running = false;
let beat = 0;
let step = 0;
let phase = 1;
let ending = false;
let fadeAlpha = 0;

const BPM = 95;
const BEAT_MS = 60000 / BPM / 4; // 16th notes

// ========== 패턴 세트 (랜덤 선택) ==========

// 드럼 패턴 세트
const drumSets = [
    { // 기본 4/4
        kick:  [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
        snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
        hihat: [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0]
    },
    { // 펑키
        kick:  [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,0,1,0],
        snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,1],
        hihat: [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0]
    },
    { // 하프타임
        kick:  [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
        snare: [0,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
        hihat: [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1]
    },
    { // 브레이크비트
        kick:  [1,0,0,0, 0,0,1,0, 0,1,0,0, 0,0,1,0],
        snare: [0,0,0,0, 1,0,0,1, 0,0,0,0, 1,0,0,0],
        hihat: [1,0,1,1, 0,0,1,0, 1,0,1,1, 0,0,1,0]
    }
];

// 코드 진행 세트 (주파수)
// C=261.63, D=293.66, E=329.63, F=349.23, G=392, A=440, B=493.88
const chordSets = [
    { // I - V - vi - IV (C - G - Am - F) 팝 진행
        name: 'Pop',
        chords: [
            [261.63, 329.63, 392.00],  // C (C-E-G)
            [392.00, 493.88, 293.66],  // G (G-B-D)
            [440.00, 261.63, 329.63],  // Am (A-C-E)
            [349.23, 440.00, 261.63]   // F (F-A-C)
        ],
        bass: [130.81, 196.00, 220.00, 174.61] // C2, G2, A2, F2
    },
    { // I - IV - V - I (클래식)
        name: 'Classic',
        chords: [
            [261.63, 329.63, 392.00],  // C
            [349.23, 440.00, 261.63],  // F
            [392.00, 493.88, 293.66],  // G
            [261.63, 329.63, 392.00]   // C
        ],
        bass: [130.81, 174.61, 196.00, 130.81]
    },
    { // vi - IV - I - V (Sad/Emotional)
        name: 'Emotional',
        chords: [
            [440.00, 261.63, 329.63],  // Am
            [349.23, 440.00, 261.63],  // F
            [261.63, 329.63, 392.00],  // C
            [392.00, 493.88, 293.66]   // G
        ],
        bass: [220.00, 174.61, 130.81, 196.00]
    },
    { // I - vi - IV - V (50s 진행)
        name: 'Retro',
        chords: [
            [261.63, 329.63, 392.00],  // C
            [440.00, 261.63, 329.63],  // Am
            [349.23, 440.00, 261.63],  // F
            [392.00, 493.88, 293.66]   // G
        ],
        bass: [130.81, 220.00, 174.61, 196.00]
    }
];

// 현재 선택된 패턴
let currentDrumSet = drumSets[0];
let currentChordSet = chordSets[0];
let currentChordIndex = 0;

function randomizePatterns() {
    currentDrumSet = drumSets[Math.floor(Math.random() * drumSets.length)];
    currentChordSet = chordSets[Math.floor(Math.random() * chordSets.length)];
    currentMelodyInst = melodyInstruments[Math.floor(Math.random() * melodyInstruments.length)];
    currentHarmonyInst = harmonyInstruments[Math.floor(Math.random() * harmonyInstruments.length)];
    currentMelodyPattern = melodyPatterns[Math.floor(Math.random() * melodyPatterns.length)];
    currentChordIndex = 0;
    console.log('Chord:', currentChordSet.name, 'Melody:', currentMelodyInst, 'Harmony:', currentHarmonyInst);
}

// ========== AUDIO ==========

function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

function kick() {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(150, audioCtx.currentTime);
    o.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.15);
    g.gain.setValueAtTime(0.8, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 0.4);
}

function snare() {
    if (!audioCtx) return;
    const len = 0.15;
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * len, audioCtx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
    const n = audioCtx.createBufferSource();
    n.buffer = buf;
    const f = audioCtx.createBiquadFilter();
    f.type = 'highpass'; f.frequency.value = 1500;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.4, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + len);
    n.connect(f); f.connect(g); g.connect(audioCtx.destination);
    n.start(); n.stop(audioCtx.currentTime + len);
}

function hihat() {
    if (!audioCtx) return;
    const len = 0.05;
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * len, audioCtx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
    const n = audioCtx.createBufferSource();
    n.buffer = buf;
    const f = audioCtx.createBiquadFilter();
    f.type = 'highpass'; f.frequency.value = 8000;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.15, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + len);
    n.connect(f); f.connect(g); g.connect(audioCtx.destination);
    n.start(); n.stop(audioCtx.currentTime + len);
}

// ========== 악기 사운드 ==========

// 피아노 (밝고 명확한 톤)
function piano(freq) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'triangle';
    o.frequency.value = freq;
    g.gain.setValueAtTime(0.25, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 1.2);
}

// 바이올린 (vibrato + 부드러운 attack)
function violin(freq) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const vibrato = audioCtx.createOscillator();
    const vibratoGain = audioCtx.createGain();

    o.type = 'sawtooth';
    o.frequency.value = freq;

    // Vibrato
    vibrato.frequency.value = 5;
    vibratoGain.gain.value = 3;
    vibrato.connect(vibratoGain);
    vibratoGain.connect(o.frequency);

    // Envelope (느린 attack)
    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.3);
    g.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 1.5);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 2);

    // Filter for warmth
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 3000;

    o.connect(filter);
    filter.connect(g);
    g.connect(audioCtx.destination);

    o.start(); vibrato.start();
    o.stop(audioCtx.currentTime + 2);
    vibrato.stop(audioCtx.currentTime + 2);
}

// 플룻 (순수한 사인파 + 공기)
function flute(freq) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = 'sine';
    o.frequency.value = freq;

    // 부드러운 envelope
    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.2);
    g.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 1);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.5);

    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 1.5);
}

// 실로폰 (밝고 빠른 decay)
function xylophone(freq) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = 'sine';
    o.frequency.value = freq;

    // 빠른 attack, 빠른 decay
    g.gain.setValueAtTime(0.3, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);

    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 0.6);
}

// 기타 (pluck 느낌)
function guitar(freq) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();

    o.type = 'triangle';
    o.frequency.value = freq;

    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(4000, audioCtx.currentTime);
    filter.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.5);

    g.gain.setValueAtTime(0.25, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);

    o.connect(filter);
    filter.connect(g);
    g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 1.5);
}

// 베이스
function bass(freq) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = 'sine';
    o.frequency.value = freq;

    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.05);
    g.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.3);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.5);

    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 1.5);
}

// 멜로디 악기 세트 (랜덤)
const melodyInstruments = ['piano', 'xylophone', 'flute', 'guitar'];

// 화성 악기 세트 (랜덤)
const harmonyInstruments = ['piano', 'flute', 'xylophone'];

let currentMelodyInst = 'piano';
let currentHarmonyInst = 'piano';

// 멜로디 패턴 (코드 톤 기반, 16스텝)
const melodyPatterns = [
    [0, -1, 1, -1, 2, -1, 1, -1, 0, -1, 2, -1, 1, -1, 0, -1],  // 기본
    [0, 1, 2, -1, 2, 1, 0, -1, 1, 2, 0, -1, 2, 1, 0, -1],      // 활발
    [0, -1, -1, 1, -1, -1, 2, -1, 1, -1, -1, 0, -1, -1, 2, -1], // 느린
    [2, 1, 0, -1, 1, 2, 0, -1, 0, 1, 2, -1, 2, 1, 0, -1]       // 하강
];
let currentMelodyPattern = melodyPatterns[0];

function playInstrument(name, freq) {
    switch(name) {
        case 'piano': piano(freq); break;
        case 'flute': flute(freq); break;
        case 'xylophone': xylophone(freq); break;
        case 'guitar': guitar(freq); break;
    }
}

// 화성 연주 (코드 전체를 동시에)
function playHarmony(chordFreqs, instName) {
    chordFreqs.forEach((freq, i) => {
        setTimeout(() => {
            playInstrument(instName, freq);
        }, i * 30); // 약간의 스트럼 느낌
    });
}

function pad(freq) {
    if (!audioCtx) return;
    const o1 = audioCtx.createOscillator();
    const o2 = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o1.type = 'sine'; o1.frequency.value = freq;
    o2.type = 'sine'; o2.frequency.value = freq * 1.5;
    g.gain.setValueAtTime(0, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 0.5);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 3);
    o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
    o1.start(); o2.start();
    o1.stop(audioCtx.currentTime + 3); o2.stop(audioCtx.currentTime + 3);
}

// 화음 재생 (코드 전체)
function playChord(chordFreqs, bassFreq) {
    if (!audioCtx) return;

    // 베이스
    const bassOsc = audioCtx.createOscillator();
    const bassGain = audioCtx.createGain();
    bassOsc.type = 'sine';
    bassOsc.frequency.value = bassFreq;
    bassGain.gain.setValueAtTime(0, audioCtx.currentTime);
    bassGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.1);
    bassGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 2);
    bassOsc.connect(bassGain);
    bassGain.connect(audioCtx.destination);
    bassOsc.start();
    bassOsc.stop(audioCtx.currentTime + 2);

    // 코드 음들 (아르페지오 느낌으로 약간 딜레이)
    chordFreqs.forEach((freq, i) => {
        setTimeout(() => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.05);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.5);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 1.5);
        }, i * 50); // 약간의 아르페지오
    });
}

// Pad 화음 (부드럽게 깔리는 배경)
function playPadChord(chordFreqs) {
    if (!audioCtx) return;

    chordFreqs.forEach(freq => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'sine';
        osc.frequency.value = freq / 2; // 한 옥타브 낮게

        filter.type = 'lowpass';
        filter.frequency.value = 500;

        gain.gain.setValueAtTime(0, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.06, audioCtx.currentTime + 0.8);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 4);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 4);
    });
}

// 최종 화음 (해결, 길게 울림)
function playFinalChord() {
    if (!audioCtx) return;

    // C Major 화음으로 해결
    const finalChord = [130.81, 261.63, 329.63, 392.00, 523.25]; // C2, C4, E4, G4, C5

    finalChord.forEach((freq, i) => {
        setTimeout(() => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = i === 0 ? 'sine' : 'triangle';
            osc.frequency.value = freq;

            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(i === 0 ? 0.2 : 0.1, audioCtx.currentTime + 0.1);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 5);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 5);
        }, i * 80);
    });
}

// ========== PARTICLES ==========

class Particle {
    constructor(x, y, r, type) {
        this.x = x;
        this.y = y;
        this.r = r;
        this.type = type;
        this.vx = 0;
        this.vy = 0;
        this.alpha = 1;
        this.hue = 0;
        this.sat = 0;
        this.lit = 100; // 흰색 시작
        this.targetX = null;
        this.targetY = null;
        this.aligned = false;
    }

    update() {
        if (this.aligned && this.targetX !== null) {
            this.x += (this.targetX - this.x) * 0.08;
            this.y += (this.targetY - this.y) * 0.08;
        } else {
            this.vy += 0.12; // gravity
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= 0.99;
            this.vy *= 0.99;

            // 바닥
            if (this.y + this.r > H) {
                this.y = H - this.r;
                this.vy *= -0.4;
            }
            // 벽
            if (this.x < this.r) { this.x = this.r; this.vx *= -0.5; }
            if (this.x > W - this.r) { this.x = W - this.r; this.vx *= -0.5; }
        }
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = `hsl(${this.hue}, ${this.sat}%, ${this.lit}%)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

let particles = [];
let mainBall = null;

function spawnBall() {
    mainBall = new Particle(W/2, -50, 50, 'main');
    mainBall.vy = 3;
    particles.push(mainBall);
}

function splitKick(p) {
    // 큰 조각 3-4개, 무겁게
    const count = 3 + Math.floor(Math.random() * 2);
    const newR = p.r * 0.55;
    for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 / count) * i - Math.PI/2;
        const np = new Particle(p.x, p.y, newR, 'kick');
        np.vx = Math.cos(angle) * 2;
        np.vy = Math.sin(angle) * 2 - 1;
        np.hue = 0; np.sat = 0; np.lit = 90;
        particles.push(np);
    }
}

function splitSnare(p) {
    // 중간 조각, 옆으로 퍼짐
    const count = 5 + Math.floor(Math.random() * 3);
    const newR = p.r * 0.4;
    for (let i = 0; i < count; i++) {
        const angle = (Math.PI / count) * i - Math.PI/2;
        const np = new Particle(p.x, p.y, newR, 'snare');
        np.vx = Math.cos(angle) * 4 + (Math.random() - 0.5) * 2;
        np.vy = -Math.random() * 2;
        np.hue = 0; np.sat = 0; np.lit = 75;
        particles.push(np);
    }
}

function splitHihat(p) {
    // 많은 작은 조각
    const count = 10 + Math.floor(Math.random() * 6);
    const newR = p.r * 0.2;
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        const np = new Particle(p.x, p.y, newR, 'hihat');
        np.vx = Math.cos(angle) * speed;
        np.vy = Math.sin(angle) * speed;
        np.hue = 0; np.sat = 0; np.lit = 60;
        particles.push(np);
    }
}

function alignParticles() {
    // 원형 패턴으로 정렬
    const cx = W / 2;
    const cy = H / 2;

    particles.forEach((p, i) => {
        const ring = Math.floor(i / 12);
        const posInRing = i % 12;
        const radius = 60 + ring * 40;
        const angle = (Math.PI * 2 / 12) * posInRing;

        p.targetX = cx + Math.cos(angle) * radius;
        p.targetY = cy + Math.sin(angle) * radius;
        p.aligned = true;

        // 색상 통일 (부드러운 파스텔)
        p.hue = 220 + ring * 20;
        p.sat = 30;
        p.lit = 70;
    });

    // 2초 후 정렬 해제 (ending 상태가 아닐 때만)
    setTimeout(() => {
        if (!ending) {
            particles.forEach(p => {
                p.aligned = false;
                p.targetX = null;
                p.vy = Math.random() * 2;
            });
        }
    }, 2500);
}

// 최종 정렬 (종료용 - 더 아름다운 패턴)
function finalAlign() {
    const cx = W / 2;
    const cy = H / 2;

    // 나선형 패턴
    particles.forEach((p, i) => {
        const angle = (i / particles.length) * Math.PI * 6; // 3바퀴
        const radius = 30 + (i / particles.length) * 120;

        p.targetX = cx + Math.cos(angle) * radius;
        p.targetY = cy + Math.sin(angle) * radius;
        p.aligned = true;

        // 흰색으로 통일
        p.hue = 0;
        p.sat = 0;
        p.lit = 100;
    });
}

// 종료 시퀀스
function triggerEnding() {
    ending = true;
    clearInterval(interval);

    // 최종 화음 재생
    playFinalChord();

    // 최종 정렬
    finalAlign();

    // 3초 후 페이드아웃 시작
    setTimeout(() => {
        const fadeInterval = setInterval(() => {
            fadeAlpha += 0.02;
            if (fadeAlpha >= 1) {
                clearInterval(fadeInterval);
                running = false;
                // 완전히 끝난 후 재시작 화면
                setTimeout(() => {
                    document.getElementById('start-screen').style.display = 'flex';
                    ending = false;
                    fadeAlpha = 0;
                }, 1000);
            }
        }, 50);
    }, 3000);
}

// ========== RHYTHM ==========

function tick() {
    beat++;
    step = beat % 16;

    // Phase 업데이트
    // Phase 1-2: 타악기 빌드업 (0-64)
    // Phase 3: 멜로디 추가 (64-96)
    // Phase 4: 화성 추가 (96-128)
    // Phase 5: 풀 사운드 (128-176)
    let phaseText = '';
    if (beat < 32) { phase = 1; phaseText = 'DRUMS'; }
    else if (beat < 64) { phase = 2; phaseText = 'RHYTHM'; }
    else if (beat < 96) { phase = 3; phaseText = 'MELODY'; }
    else if (beat < 128) { phase = 4; phaseText = 'HARMONY'; }
    else { phase = 5; phaseText = 'FULL'; }
    document.getElementById('phase').textContent = phaseText;

    let playedKick = false, playedSnare = false, playedHihat = false;

    // 현재 드럼 패턴 사용
    const drums = currentDrumSet;

    // Phase 1: Kick만
    if (phase >= 1 && drums.kick[step]) {
        kick();
        playedKick = true;
    }

    // Phase 1 후반: Snare 추가
    if (phase >= 1 && beat >= 16 && drums.snare[step]) {
        snare();
        playedSnare = true;
    }

    // Phase 2: Hi-hat 추가
    if (phase >= 2 && drums.hihat[step]) {
        hihat();
        playedHihat = true;
    }

    // Phase 3+: 멜로디와 화성
    if (phase >= 3) {
        const chords = currentChordSet.chords;

        // 코드 체인지 (매 4비트)
        if (step === 0) currentChordIndex = 0;
        if (step === 4) currentChordIndex = 1;
        if (step === 8) currentChordIndex = 2;
        if (step === 12) currentChordIndex = 3;

        const currentChord = chords[currentChordIndex];

        // Phase 3: 멜로디 라인 (단일 음 순차 연주)
        if (phase >= 3) {
            const melodyNote = currentMelodyPattern[step];
            if (melodyNote >= 0) {
                // 멜로디는 코드 톤 중 하나를 한 옥타브 높게
                const freq = currentChord[melodyNote] * 2;
                playInstrument(currentMelodyInst, freq);
            }
        }

        // Phase 4: 화성 추가 (코드 전체를 동시에)
        if (phase >= 4 && step % 4 === 0) {
            playHarmony(currentChord, currentHarmonyInst);
        }

        // Phase 5: Pad 배경 + 화성 더 자주
        if (phase >= 5) {
            if (step === 0) {
                playPadChord(currentChord);
            }
            // 화성을 2박마다
            if (step % 8 === 0 || step % 8 === 4) {
                playHarmony(currentChord, currentHarmonyInst);
            }
        }
    }

    // 비주얼: 쪼개기
    const toSplit = particles.filter(p => p.r > 8 && !p.aligned);

    if (playedKick && toSplit.length > 0) {
        const p = toSplit.find(p => p.r > 25) || toSplit[0];
        splitKick(p);
        particles = particles.filter(x => x !== p);
    }

    if (playedSnare) {
        const candidates = particles.filter(p => p.r > 12 && p.r <= 35 && !p.aligned);
        if (candidates.length > 0) {
            const p = candidates[Math.floor(Math.random() * candidates.length)];
            splitSnare(p);
            particles = particles.filter(x => x !== p);
        }
    }

    if (playedHihat) {
        const candidates = particles.filter(p => p.r > 5 && p.r <= 20 && !p.aligned);
        if (candidates.length > 0) {
            const p = candidates[Math.floor(Math.random() * candidates.length)];
            splitHihat(p);
            particles = particles.filter(x => x !== p);
        }
    }

    // Phase 3: 정렬
    if (phase >= 3 && step === 0 && particles.length > 10 && !ending) {
        alignParticles();
    }

    // 종료 조건: Phase 5에서 176비트 (약 44초) 후
    if (beat >= 176 && !ending) {
        triggerEnding();
        return;
    }

    // 새 공 생성
    if (step === 0 && particles.filter(p => p.r > 30).length < 2) {
        spawnBall();
    }

    // 파티클 수 제한
    if (particles.length > 150) {
        particles = particles.slice(-100);
    }
}

// ========== RENDER ==========

function draw() {
    // 검은 배경
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);

    // 파티클
    particles.forEach(p => {
        p.update();
        p.draw();
    });

    // 페이드아웃 오버레이
    if (fadeAlpha > 0) {
        ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
        ctx.fillRect(0, 0, W, H);
    }
}

function loop() {
    if (!running) return;
    draw();
    requestAnimationFrame(loop);
}

// ========== INIT ==========

let interval = null;

function start() {
    document.getElementById('start-screen').style.display = 'none';
    initAudio();
    running = true;
    beat = 0;
    step = 0;
    phase = 1;
    particles = [];

    // 랜덤 패턴 선택
    randomizePatterns();

    spawnBall();
    interval = setInterval(tick, BEAT_MS);
    loop();
}

function init() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);

    const ss = document.getElementById('start-screen');
    ss.addEventListener('click', () => { if (!running) start(); });
    ss.addEventListener('touchstart', () => { if (!running) start(); });
}

window.onload = init;
</script>
</body>
</html>
