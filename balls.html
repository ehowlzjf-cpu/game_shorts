<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory Battle</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 360px;
            height: 640px;
            overflow: hidden;
        }
        canvas { display: block; }
        #start-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        #start-text {
            font-family: 'Arial', sans-serif;
            font-size: 24px;
            color: #fff;
            letter-spacing: 4px;
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        #scoreboard {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-around;
            font-family: 'Arial', sans-serif;
            font-size: 12px;
            font-weight: bold;
            z-index: 5;
        }
        .score {
            padding: 4px 8px;
            border-radius: 10px;
            color: #000;
        }
        #winner-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }
        #winner-text {
            font-family: 'Arial', sans-serif;
            font-size: 28px;
            color: #fff;
            margin-bottom: 20px;
        }
        #winner-color {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin-bottom: 30px;
            animation: winPulse 0.5s ease-in-out infinite;
        }
        @keyframes winPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        #description {
            position: absolute;
            bottom: 15px;
            left: 10px;
            right: 10px;
            text-align: center;
            font-family: 'Arial', sans-serif;
            font-size: 10px;
            color: rgba(255,255,255,0.5);
            z-index: 5;
        }
        #shape-name {
            position: absolute;
            top: 45px;
            left: 0;
            right: 0;
            text-align: center;
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            z-index: 5;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="canvas"></canvas>
        <div id="scoreboard">
            <div class="score" id="score0" style="background:#ff6b6b;">0</div>
            <div class="score" id="score1" style="background:#4ecdc4;">0</div>
            <div class="score" id="score2" style="background:#ffe66d;">0</div>
            <div class="score" id="score3" style="background:#a29bfe;">0</div>
        </div>
        <div id="shape-name"></div>
        <div id="start-screen">
            <div id="start-text">TAP TO START</div>
        </div>
        <div id="winner-screen">
            <div id="winner-text">WINNER!</div>
            <div id="winner-color"></div>
        </div>
        <div id="description">
            Capture 80% of zones to win!
        </div>
    </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const W = 360, H = 640;
canvas.width = W;
canvas.height = H;

const CENTER = { x: W / 2, y: H / 2 };
const COLORS = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#a29bfe'];
const COLORS_LIGHT = ['rgba(255,107,107,0.3)', 'rgba(78,205,196,0.3)', 'rgba(255,230,109,0.3)', 'rgba(162,155,254,0.3)'];
const BALL_SPEED = 2;

let audioCtx = null;
let balls = [];
let running = false;
let winner = null;
let arenaVertices = [];
let arenaName = '';
let grid = []; // 100 cells, each has owner (-1 = none, 0-3 = color)
let gridCells = []; // cell boundaries

// ========== AUDIO ==========

function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playCaptureSound(colorIndex) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const baseFreq = [523, 587, 659, 698][colorIndex];
    osc.type = 'sine';
    osc.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
}

function playEnclosureSound() {
    if (!audioCtx) return;
    const notes = [523, 659, 784];
    notes.forEach((freq, i) => {
        setTimeout(() => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.15);
        }, i * 80);
    });
}

function playWinSound() {
    if (!audioCtx) return;
    const notes = [523, 659, 784, 1047];
    notes.forEach((freq, i) => {
        setTimeout(() => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }, i * 150);
    });
}

// ========== ARENA SHAPES ==========

const SHAPES = [
    { name: 'STAR', sides: 5, star: true },
    { name: 'PENTAGON', sides: 5, star: false },
    { name: 'HEXAGON', sides: 6, star: false },
    { name: 'SQUARE', sides: 4, star: false },
    { name: 'OCTAGON', sides: 8, star: false },
    { name: 'TRIANGLE', sides: 3, star: false },
    { name: 'HEPTAGON', sides: 7, star: false },
];

function generateArena() {
    const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
    arenaName = shape.name;
    document.getElementById('shape-name').textContent = arenaName;

    arenaVertices = [];
    const outerR = 140;
    const innerR = 60;

    if (shape.star) {
        // 별 모양
        for (let i = 0; i < shape.sides * 2; i++) {
            const angle = (i * Math.PI / shape.sides) - Math.PI / 2;
            const r = (i % 2 === 0) ? outerR : innerR;
            arenaVertices.push({
                x: CENTER.x + Math.cos(angle) * r,
                y: CENTER.y + Math.sin(angle) * r
            });
        }
    } else {
        // 일반 다각형
        for (let i = 0; i < shape.sides; i++) {
            const angle = (i * 2 * Math.PI / shape.sides) - Math.PI / 2;
            arenaVertices.push({
                x: CENTER.x + Math.cos(angle) * outerR,
                y: CENTER.y + Math.sin(angle) * outerR
            });
        }
    }
}

function pointInPolygon(px, py, vertices) {
    let inside = false;
    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i].x, yi = vertices[i].y;
        const xj = vertices[j].x, yj = vertices[j].y;
        if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
            inside = !inside;
        }
    }
    return inside;
}

// ========== GRID SYSTEM ==========

const TARGET_CELLS = 100;

function initGrid() {
    grid = [];
    gridCells = [];

    // 경계 박스 계산
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    arenaVertices.forEach(v => {
        minX = Math.min(minX, v.x);
        maxX = Math.max(maxX, v.x);
        minY = Math.min(minY, v.y);
        maxY = Math.max(maxY, v.y);
    });

    // 그리드 사이즈 조절해서 100개 맞추기
    let gridSize = 10;
    let insideCount = 0;

    // 적절한 그리드 사이즈 찾기
    for (let trySize = 8; trySize <= 20; trySize++) {
        const cellW = (maxX - minX) / trySize;
        const cellH = (maxY - minY) / trySize;
        let count = 0;

        for (let row = 0; row < trySize; row++) {
            for (let col = 0; col < trySize; col++) {
                const cx = minX + (col + 0.5) * cellW;
                const cy = minY + (row + 0.5) * cellH;
                if (pointInPolygon(cx, cy, arenaVertices)) count++;
            }
        }

        if (Math.abs(count - TARGET_CELLS) < Math.abs(insideCount - TARGET_CELLS)) {
            gridSize = trySize;
            insideCount = count;
        }
    }

    const cellW = (maxX - minX) / gridSize;
    const cellH = (maxY - minY) / gridSize;

    // 실제 그리드 생성 (안에 있는 셀만)
    for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
            const cx = minX + (col + 0.5) * cellW;
            const cy = minY + (row + 0.5) * cellH;

            if (!pointInPolygon(cx, cy, arenaVertices)) continue;

            const cell = {
                x: minX + col * cellW,
                y: minY + row * cellH,
                w: cellW,
                h: cellH,
                cx: cx,
                cy: cy,
                inside: true,
                owner: -1
            };
            gridCells.push(cell);
            grid.push(-1);
        }
    }

    console.log('Total cells:', gridCells.length);
}

function getCellAt(x, y) {
    for (let i = 0; i < gridCells.length; i++) {
        const c = gridCells[i];
        if (x >= c.x && x < c.x + c.w && y >= c.y && y < c.y + c.h) {
            return i;
        }
    }
    return -1;
}

function captureCell(idx, colorIndex) {
    if (idx < 0 || idx >= grid.length) return false;
    if (!gridCells[idx].inside) return false;
    if (grid[idx] === colorIndex) return false;

    grid[idx] = colorIndex;
    gridCells[idx].owner = colorIndex;
    return true;
}

// ========== BALL CLASS ==========

class Ball {
    constructor(x, y, colorIndex) {
        this.x = x;
        this.y = y;
        this.colorIndex = colorIndex;
        this.radius = 6;
        this.dead = false;

        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * BALL_SPEED;
        this.vy = Math.sin(angle) * BALL_SPEED;

        this.trail = []; // 실선 경로
        this.lastCaptureCell = -1;
    }

    update() {
        if (this.dead) return;

        const prevX = this.x;
        const prevY = this.y;

        this.x += this.vx;
        this.y += this.vy;

        // 벽 충돌 (반사만, 도형 완성 X)
        if (!pointInPolygon(this.x, this.y, arenaVertices)) {
            this.x = prevX;
            this.y = prevY;

            const toCenterX = CENTER.x - this.x;
            const toCenterY = CENTER.y - this.y;
            const len = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY) || 1;
            const nx = toCenterX / len;
            const ny = toCenterY / len;
            const angle = Math.atan2(ny, nx) + (Math.random() - 0.5) * 0.8;
            this.vx = Math.cos(angle) * BALL_SPEED;
            this.vy = Math.sin(angle) * BALL_SPEED;
        }

        // 실선에 현재 위치 추가 (계속 길어짐)
        this.trail.push({ x: this.x, y: this.y });

        // 지나가는 셀 즉시 점령
        const cellIdx = getCellAt(this.x, this.y);
        if (cellIdx >= 0 && gridCells[cellIdx].inside && cellIdx !== this.lastCaptureCell) {
            if (grid[cellIdx] !== this.colorIndex) {
                grid[cellIdx] = this.colorIndex;
                gridCells[cellIdx].owner = this.colorIndex;
                playCaptureSound(this.colorIndex);
            }
            this.lastCaptureCell = cellIdx;
        }

        // 자기 실선과 교차하는지 체크 (도형 완성)
        this.checkSelfIntersection();

        // 공끼리 충돌
        balls.forEach(other => {
            if (other === this || other.dead) return;
            const dx = other.x - this.x;
            const dy = other.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < this.radius + other.radius && dist > 0) {
                const nx = dx / dist;
                const ny = dy / dist;
                const overlap = (this.radius + other.radius - dist) / 2;
                this.x -= nx * overlap;
                this.y -= ny * overlap;
                other.x += nx * overlap;
                other.y += ny * overlap;

                const dvx = this.vx - other.vx;
                const dvy = this.vy - other.vy;
                const dot = dvx * nx + dvy * ny;
                this.vx -= dot * nx;
                this.vy -= dot * ny;
                other.vx += dot * nx;
                other.vy += dot * ny;

                this.normalizeSpeed();
                other.normalizeSpeed();
            }
        });
    }

    checkSelfIntersection() {
        // 최소 50개 포인트 있어야 도형 체크
        if (this.trail.length < 50) return;

        const curr = this.trail[this.trail.length - 1];

        // 오래된 포인트와 가까워졌는지 체크
        for (let i = 0; i < this.trail.length - 40; i++) {
            const old = this.trail[i];
            const dist = Math.sqrt((curr.x - old.x) ** 2 + (curr.y - old.y) ** 2);

            if (dist < 8) {
                // 도형 완성! i부터 끝까지가 폐곡선
                const polygon = this.trail.slice(i);
                if (polygon.length >= 30) {
                    this.completeShape(polygon, i);
                }
                return;
            }
        }
    }

    completeShape(polygon, startIdx) {
        let capturedCount = 0;

        // 폐곡선 안의 모든 셀 점령
        gridCells.forEach((cell, idx) => {
            if (!cell.inside) return;
            if (pointInPolygon(cell.cx, cell.cy, polygon)) {
                if (grid[idx] !== this.colorIndex) capturedCount++;
                grid[idx] = this.colorIndex;
                cell.owner = this.colorIndex;
            }
        });

        if (capturedCount > 0) {
            playEnclosureSound();
        }

        // 폐곡선 안의 다른 공 제거
        balls.forEach(other => {
            if (other === this || other.dead) return;
            if (pointInPolygon(other.x, other.y, polygon)) {
                other.dead = true;
                spawnDeathParticles(other.x, other.y, other.colorIndex);
            }
        });

        // 폐곡선 안의 다른 공 실선 제거
        balls.forEach(other => {
            if (other === this) return;
            const newTrail = [];
            for (const p of other.trail) {
                if (!pointInPolygon(p.x, p.y, polygon)) {
                    newTrail.push(p);
                }
            }
            other.trail = newTrail;
        });

        // 내 실선 완전 초기화
        this.trail = [];
    }

    normalizeSpeed() {
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        if (speed > 0) {
            this.vx = (this.vx / speed) * BALL_SPEED;
            this.vy = (this.vy / speed) * BALL_SPEED;
        }
    }

    draw() {
        if (this.dead) return;

        // 경로 그리기 (전체)
        if (this.trail.length > 1) {
            ctx.strokeStyle = COLORS[this.colorIndex];
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for (let i = 1; i < this.trail.length; i++) {
                ctx.lineTo(this.trail[i].x, this.trail[i].y);
            }
            ctx.stroke();
        }

        // 공
        ctx.fillStyle = COLORS[this.colorIndex];
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

// 사망 파티클
let deathParticles = [];

function spawnDeathParticles(x, y, colorIndex) {
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        deathParticles.push({
            x, y,
            vx: Math.cos(angle) * 4,
            vy: Math.sin(angle) * 4,
            life: 40,
            color: COLORS[colorIndex]
        });
    }
}

function updateDeathParticles() {
    deathParticles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life--;
    });
    deathParticles = deathParticles.filter(p => p.life > 0);
}

function drawDeathParticles() {
    deathParticles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 40;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;
}

// ========== GAME LOGIC ==========

function createBalls() {
    balls = [];

    // 4개 공을 맵 안 랜덤 위치에 배치
    const positions = [];
    for (let i = 0; i < 4; i++) {
        let x, y, valid = false;
        let attempts = 0;
        while (!valid && attempts < 100) {
            x = CENTER.x + (Math.random() - 0.5) * 100;
            y = CENTER.y + (Math.random() - 0.5) * 100;
            valid = pointInPolygon(x, y, arenaVertices);
            // 다른 공과 거리 확인
            positions.forEach(p => {
                if (Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2) < 30) valid = false;
            });
            attempts++;
        }
        positions.push({ x, y });
        balls.push(new Ball(x, y, i));
    }
}

function countTerritory() {
    const counts = [0, 0, 0, 0];
    grid.forEach((owner) => {
        if (owner >= 0) {
            counts[owner]++;
        }
    });
    return counts;
}

function updateScoreboard() {
    const counts = countTerritory();
    for (let i = 0; i < 4; i++) {
        document.getElementById('score' + i).textContent = counts[i];
    }
}

function checkWinner() {
    const counts = countTerritory();
    const winTarget = Math.floor(gridCells.length * 0.8); // 80% 점령시 승리
    for (let i = 0; i < 4; i++) {
        if (counts[i] >= winTarget) {
            return i;
        }
    }
    return null;
}

// ========== RENDERING ==========

function draw() {
    // 배경
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, W, H);

    // 클리핑 패스 설정 (도형 안에만 그리기)
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(arenaVertices[0].x, arenaVertices[0].y);
    for (let i = 1; i < arenaVertices.length; i++) {
        ctx.lineTo(arenaVertices[i].x, arenaVertices[i].y);
    }
    ctx.closePath();
    ctx.clip();

    // 그리드 셀 그리기 (클리핑된 상태)
    gridCells.forEach((cell, idx) => {
        const owner = grid[idx];
        if (owner >= 0) {
            ctx.fillStyle = COLORS_LIGHT[owner];
        } else {
            ctx.fillStyle = 'rgba(255,255,255,0.05)';
        }
        ctx.fillRect(cell.x, cell.y, cell.w, cell.h);

        // 셀 테두리
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1;
        ctx.strokeRect(cell.x, cell.y, cell.w, cell.h);
    });

    ctx.restore();

    // 경기장 테두리
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(arenaVertices[0].x, arenaVertices[0].y);
    for (let i = 1; i < arenaVertices.length; i++) {
        ctx.lineTo(arenaVertices[i].x, arenaVertices[i].y);
    }
    ctx.closePath();
    ctx.stroke();

    // 공들
    balls.forEach(b => b.draw());

    // 사망 파티클
    drawDeathParticles();
}

function gameLoop() {
    if (!running) return;

    balls.forEach(b => b.update());
    updateDeathParticles();
    updateScoreboard();

    // 살아있는 공이 1개면 승리
    const aliveBalls = balls.filter(b => !b.dead);
    if (aliveBalls.length === 1) {
        winner = aliveBalls[0].colorIndex;
        running = false;
        showWinner(winner);
        return;
    }

    // 80개 달성 체크
    const w = checkWinner();
    if (w !== null) {
        winner = w;
        running = false;
        showWinner(w);
        return;
    }

    draw();
    requestAnimationFrame(gameLoop);
}

function showWinner(colorIndex) {
    draw();
    playWinSound();
    document.getElementById('winner-color').style.background = COLORS[colorIndex];
    document.getElementById('winner-screen').style.display = 'flex';
}

function start() {
    document.getElementById('start-screen').style.display = 'none';
    initAudio();

    generateArena();
    initGrid();
    createBalls();

    running = true;
    gameLoop();
}

function init() {
    // 프리뷰용 임시 경기장
    generateArena();
    initGrid();
    draw();

    const ss = document.getElementById('start-screen');
    ss.addEventListener('click', () => { if (!running && winner === null) start(); });
    ss.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!running && winner === null) start();
    });
}

window.onload = init;
</script>
</body>
</html>
